{
  "version": 3,
  "sources": ["../src/index.ts", "../src/token.ts", "../src/constant.ts", "../src/scanner.ts", "../src/util.ts", "../src/expression.ts", "../src/statement.ts", "../src/parser.ts", "../src/environment.ts", "../src/function.ts", "../src/return.ts", "../src/class.ts", "../src/interpreter.ts", "../src/jsjs.ts", "../src/native.ts"],
  "sourcesContent": ["import { interpret } from './jsjs';\nimport EnvironmentImpl from './environment';\nimport { getGlobalObject } from './native';\nexport { EnvironmentImpl as Environment, getGlobalObject, interpret };\n", "import { TokenType } from './tokenType';\nclass Token {\n  readonly type: TokenType;\n  readonly lexeme: string;\n  readonly line: number;\n\n  constructor(type: TokenType, lexeme: string, line: number) {\n    this.type = type;\n    this.lexeme = lexeme;\n    this.line = line;\n  }\n\n  toString() {\n    if (this.type === TokenType.STRING) {\n      return `'${this.lexeme}'`;\n    }\n    return this.lexeme;\n  }\n}\n\nexport default Token;\n", "import { TokenType } from './tokenType';\n// await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield\nexport const KEYWORD_MAP: Map<string, TokenType> = new Map([\n  ['class', TokenType.CLASS],\n  ['else', TokenType.ELSE],\n  ['false', TokenType.FALSE],\n  ['for', TokenType.FOR],\n  ['function', TokenType.FUNCTION],\n  ['if', TokenType.IF],\n  ['null', TokenType.NULL],\n  ['return', TokenType.RETURN],\n  // ['super', TokenType.SUPER],\n  // ['this', TokenType.THIS],\n  ['true', TokenType.TRUE],\n  ['var', TokenType.VAR],\n  ['while', TokenType.WHILE],\n  ['do', TokenType.DO_WHILE],\n  ['new', TokenType.NEW],\n  ['static', TokenType.STATIC],\n  ['undefined', TokenType.UNDEFINED],\n  ['extends', TokenType.EXTENDS],\n  ['typeof', TokenType.TYPEOF],\n  ['delete', TokenType.DELETE],\n  ['void', TokenType.VOID],\n  ['in', TokenType.IN],\n  ['instanceof', TokenType.INSTANCE_OF],\n]);\n\nexport const EMPTY_DATA = '\\0';\n", "import Token from './token';\nimport { TokenType } from './tokenType';\nimport { KEYWORD_MAP, EMPTY_DATA } from './constant';\n\nclass Scanner {\n  readonly source: string[];\n  readonly tokens: Token[] = [];\n  readonly errors: string[] = [];\n  private start = 0;\n  private current = 0;\n  private line = 1;\n\n  constructor(text: string) {\n    // unicode\n    this.source = [...text];\n  }\n  scan = () => {\n    while (!this.isAtEnd()) {\n      this.start = this.current;\n      this.scanToken();\n    }\n    this.tokens.push(new Token(TokenType.EOF, '', this.line));\n    return this.tokens;\n  };\n  private addError = (line: number, message: string) => {\n    const msg = `line: ${line},scanner error : ${message} `;\n    throw new Error(msg);\n  };\n  private isAtEnd() {\n    return this.current >= this.source.length;\n  }\n  private substr(start = this.start, end = this.current): string {\n    return this.source.slice(start, end).join('');\n  }\n  private addOneToken(type: TokenType, value = this.substr()) {\n    this.tokens.push(new Token(type, value, this.line));\n  }\n  private getChar(index: number) {\n    return this.source[index] as string;\n  }\n  private peek() {\n    if (this.isAtEnd()) {\n      return EMPTY_DATA;\n    }\n    return this.getChar(this.current);\n  }\n  private peekNext() {\n    if (this.current + 1 < this.source.length) {\n      return this.getChar(this.current + 1);\n    }\n    return EMPTY_DATA;\n  }\n  private match(expected: string) {\n    if (this.isAtEnd()) {\n      return false;\n    }\n    if (this.getChar(this.current) !== expected) {\n      return false;\n    }\n\n    this.current++;\n    return true;\n  }\n  private advance() {\n    return this.getChar(this.current++);\n  }\n  private scanToken() {\n    const c = this.advance();\n    switch (c) {\n      case '(':\n        this.addOneToken(TokenType.LEFT_BRACKET);\n        break;\n      case ')':\n        this.addOneToken(TokenType.RIGHT_BRACKET);\n        break;\n      case '{':\n        this.addOneToken(TokenType.lEFT_BRACE);\n        break;\n      case '}':\n        this.addOneToken(TokenType.RIGHT_BRACE);\n        break;\n      case '[':\n        this.addOneToken(TokenType.LEFT_SQUARE_BRACKET);\n        break;\n      case ']':\n        this.addOneToken(TokenType.RIGHT_SQUARE_BRACKET);\n        break;\n      case ':':\n        this.addOneToken(TokenType.COLON);\n        break;\n      case ',':\n        this.addOneToken(TokenType.COMMA);\n        break;\n      case '.':\n        this.addOneToken(TokenType.DOT);\n        break;\n      case '-':\n        if (this.match('-')) {\n          this.addOneToken(TokenType.MINUS_MINUS);\n        } else {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.MINUS_EQUAL);\n          } else {\n            this.addOneToken(TokenType.MINUS);\n          }\n        }\n        break;\n      case '+':\n        if (this.match('+')) {\n          this.addOneToken(TokenType.PLUS_PLUS);\n        } else {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.PLUS_EQUAL);\n          } else {\n            this.addOneToken(TokenType.PLUS);\n          }\n        }\n        break;\n      case ';':\n        this.addOneToken(TokenType.SEMICOLON);\n        break;\n      case '*':\n        if (this.match('=')) {\n          this.addOneToken(TokenType.STAR_EQUAL);\n        } else if (this.match('*')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.STAR_STAR_EQUAL);\n          } else {\n            this.addOneToken(TokenType.STAR_STAR);\n          }\n        } else {\n          this.addOneToken(TokenType.STAR);\n        }\n        break;\n      case '%':\n        if (this.match('=')) {\n          this.addOneToken(TokenType.REMAINDER_EQUAL);\n        } else {\n          this.addOneToken(TokenType.REMAINDER);\n        }\n        break;\n      case '!':\n        if (this.match('=')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.BANG_EQUAL_EQUAL);\n          } else {\n            this.addOneToken(TokenType.BANG_EQUAL);\n          }\n        } else {\n          this.addOneToken(TokenType.BANG);\n        }\n        break;\n      case '=':\n        if (this.match('=')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.EQUAL_EQUAL_EQUAL);\n          } else {\n            this.addOneToken(TokenType.EQUAL_EQUAL);\n          }\n        } else {\n          this.addOneToken(TokenType.EQUAL);\n        }\n        break;\n      case '?':\n        if (this.match('?')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.NULLISH_COALESCING_EQUAL);\n          } else {\n            this.addOneToken(TokenType.NULLISH_COALESCING);\n          }\n        } else {\n          this.addOneToken(TokenType.QUESTION_MARK);\n        }\n        break;\n      case '>':\n        if (this.match('=')) {\n          this.addOneToken(TokenType.GREATER_EQUAL);\n        } else if (this.match('>')) {\n          if (this.match('>')) {\n            if (this.match('=')) {\n              this.addOneToken(TokenType.UNSIGNED_RIGHT_SHIFT_EQUAL);\n            } else {\n              this.addOneToken(TokenType.UNSIGNED_RIGHT_SHIFT);\n            }\n          } else if (this.match('=')) {\n            this.addOneToken(TokenType.RIGHT_SHIFT_EQUAL);\n          } else {\n            this.addOneToken(TokenType.RIGHT_SHIFT);\n          }\n        } else {\n          this.addOneToken(TokenType.GREATER);\n        }\n        break;\n      case '<':\n        if (this.match('=')) {\n          this.addOneToken(TokenType.LESS_EQUAL);\n        } else if (this.match('<')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.LEFT_SHIFT_EQUAL);\n          } else {\n            this.addOneToken(TokenType.LEFT_SHIFT);\n          }\n        } else {\n          this.addOneToken(TokenType.LESS);\n        }\n        break;\n      case '/':\n        // single line comment\n        if (this.match('/')) {\n          while (this.peek() !== '\\n' && !this.isAtEnd()) {\n            this.advance();\n          }\n        } else if (this.match('*')) {\n          /* multiple line comments */\n          while (\n            !(\n              (this.peek() === '*' && this.peekNext() === '/') ||\n              this.isAtEnd()\n            )\n          ) {\n            this.advance();\n            if (this.peek() === '\\n') {\n              this.line++;\n            }\n          }\n          if (this.peekNext() !== '/') {\n            this.addError(this.line, 'multiple line comment end error');\n          }\n          this.advance(); // skip *\n          this.advance(); // skip /\n        } else if (this.match('=')) {\n          this.addOneToken(TokenType.SLASH_EQUAL);\n        } else {\n          this.addOneToken(TokenType.SLASH);\n        }\n        break;\n      case '|':\n        if (this.match('|')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.OR_EQUAL);\n          } else {\n            this.addOneToken(TokenType.OR);\n          }\n        } else if (this.match('=')) {\n          this.addOneToken(TokenType.BIT_OR_EQUAL);\n        } else {\n          this.addOneToken(TokenType.BIT_OR);\n        }\n        break;\n      case '^':\n        if (this.match('=')) {\n          this.addOneToken(TokenType.BIT_X_OR_EQUAL);\n        } else {\n          this.addOneToken(TokenType.BIT_X_OR);\n        }\n        break;\n      case '~':\n        this.addOneToken(TokenType.BIT_NOT);\n        break;\n      case '&':\n        if (this.match('&')) {\n          if (this.match('=')) {\n            this.addOneToken(TokenType.AND_EQUAL);\n          } else {\n            this.addOneToken(TokenType.AND);\n          }\n        } else if (this.match('=')) {\n          this.addOneToken(TokenType.BIT_AND_EQUAL);\n        } else {\n          this.addOneToken(TokenType.BIT_AND);\n        }\n        break;\n      case ' ':\n      case '\\r':\n      case '\\t':\n        // whitespace\n        break;\n      case '\\n':\n        this.line++;\n        break;\n      case '\"':\n        this.string(c);\n        break;\n      case \"'\":\n        this.string(c);\n        break;\n      default:\n        if (this.isDigit(c)) {\n          this.number();\n        } else if (this.identifierChar(c)) {\n          this.identifier();\n        } else {\n          this.addError(this.line, `Unexpected character: ${c}`);\n        }\n        break;\n    }\n  }\n  private string(splitter: string) {\n    while (this.peek() !== splitter && !this.isAtEnd()) {\n      if (this.peek() === '\\n') {\n        this.line++;\n      }\n      this.advance();\n    }\n    if (this.isAtEnd()) {\n      this.addError(this.line, 'Unterminated string');\n      return;\n    }\n    this.advance();\n    const value = this.substr(this.start + 1, this.current - 1);\n    this.addOneToken(TokenType.STRING, value);\n  }\n  private number() {\n    while (this.isDigit(this.peek())) {\n      this.advance();\n    }\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      this.advance();\n      while (this.isDigit(this.peek())) {\n        this.advance();\n      }\n    }\n    this.addOneToken(TokenType.NUMBER);\n  }\n  private identifier() {\n    while (this.identifierChar(this.peek())) {\n      this.advance();\n    }\n    const text = this.substr();\n    const temp = KEYWORD_MAP.get(text);\n    let type: TokenType = TokenType.IDENTIFIER;\n    if (temp !== undefined) {\n      type = temp;\n    }\n    this.addOneToken(type);\n  }\n  private identifierChar(c: string): boolean {\n    const temp = `()[]{},.=-*/%!&<>|';\":`;\n    return !(this.isWhiteSpace(c) || temp.includes(c));\n  }\n  private isWhiteSpace(c: string) {\n    return c === ' ' || c === '\\r' || c === '\\n' || c === '\\t';\n  }\n  private isDigit(char: string) {\n    return char >= '0' && char <= '9';\n  }\n}\nexport default Scanner;\n", "import type { LiteralType, IBaseCallable, ObjectType } from './type';\n\nexport function convertLiteralTypeToString(val: LiteralType): string {\n  if (val === null) {\n    return 'null';\n  }\n  if (val === undefined) {\n    return 'undefined';\n  }\n  if (typeof val === 'string') {\n    return val;\n  }\n  if (typeof val === 'boolean') {\n    return val.toString();\n  }\n  if (typeof val === 'number') {\n    return val.toString();\n  }\n  if (val && typeof val.toString === 'function') {\n    return val.toString();\n  }\n  return '';\n}\n\nfunction isFunction(fun: any): fun is Function {\n  return typeof fun === 'function';\n}\n\nexport function isBaseCallable(call: any): call is IBaseCallable {\n  return call && isFunction(call.toString) && isFunction(call.call);\n}\n\nexport function getNodeEnv(): string {\n  return process.env['NODE_ENV'] || '';\n}\n\nexport function isTestEnv(): boolean {\n  return getNodeEnv() === 'test';\n}\n\nexport function assert(\n  condition: boolean,\n  message = 'assert error',\n): asserts condition {\n  if (!condition) {\n    if (getNodeEnv() === 'production') {\n      console.error(message);\n      return;\n    }\n    throw new Error(message);\n  }\n}\n\nexport function isObject(obj: any): obj is ObjectType {\n  return obj && typeof obj === 'object';\n}\n", "import type Token from './token';\nimport type { LiteralType } from './type';\nimport { convertLiteralTypeToString, isTestEnv } from './util';\nimport type {\n  BlockStatement,\n  VariableStatement,\n  FunctionStatement,\n} from './statement';\nexport interface ExpressionVisitor {\n  visitNewExpression: (Expression: NewExpression) => LiteralType;\n  visitAssignExpression: (expression: AssignExpression) => LiteralType;\n  visitBinaryExpression: (expression: BinaryExpression) => LiteralType;\n  visitCallExpression: (expression: CallExpression) => LiteralType;\n  visitGetExpression: (expression: GetExpression) => LiteralType;\n  visitSetExpression: (expression: SetExpression) => LiteralType;\n  visitGroupingExpression: (expression: GroupingExpression) => LiteralType;\n  visitLiteralExpression: (expression: LiteralExpression) => LiteralType;\n  visitLogicalExpression: (expression: LogicalExpression) => LiteralType;\n  visitSuperExpression: (expression: SuperExpression) => LiteralType;\n  visitThisExpression: (expression: ThisExpression) => LiteralType;\n  visitUnaryExpression: (expression: UnaryExpression) => LiteralType;\n  visitVariableExpression: (expression: VariableExpression) => LiteralType;\n  visitFunctionExpression: (expression: FunctionExpression) => LiteralType;\n  visitArrayLiteralExpression: (\n    expression: ArrayLiteralExpression,\n  ) => LiteralType;\n  visitObjectLiteralExpression: (\n    expression: ObjectLiteralExpression,\n  ) => LiteralType;\n  visitTokenExpression: (expression: TokenExpression) => LiteralType;\n  visitClassExpression: (expression: ClassExpression) => LiteralType;\n}\nexport interface Expression {\n  accept(visitor: ExpressionVisitor): LiteralType;\n  toString(): string;\n}\nexport class NewExpression implements Expression {\n  readonly callee: Expression;\n  constructor(callee: Expression) {\n    this.callee = callee;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitNewExpression(this);\n  }\n  toString() {\n    return `new ${this.callee.toString()}`;\n  }\n}\nexport class AssignExpression implements Expression {\n  readonly left: Token;\n  readonly right: Expression;\n  constructor(left: Token, right: Expression) {\n    this.left = left;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitAssignExpression(this);\n  }\n  toString() {\n    return `${this.left.toString()} = ${this.right.toString()}`;\n  }\n}\nexport class BinaryExpression implements Expression {\n  readonly left: Expression;\n  readonly operator: Token;\n  readonly right: Expression;\n  constructor(left: Expression, operator: Token, right: Expression) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitBinaryExpression(this);\n  }\n  toString() {\n    const temp = `${this.left.toString()} ${this.operator.toString()} ${this.right.toString()}`;\n    if (isTestEnv()) {\n      return `(${temp})`;\n    }\n    return temp;\n  }\n}\nexport class CallExpression implements Expression {\n  readonly callee: Expression;\n  readonly argumentList: Expression[];\n  constructor(callee: Expression, argumentList: Expression[]) {\n    this.callee = callee;\n    this.argumentList = argumentList;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitCallExpression(this);\n  }\n  toString() {\n    return `${this.callee.toString()}(${this.argumentList\n      .map((item) => item.toString())\n      .join(',')})`;\n  }\n}\nexport class GetExpression implements Expression {\n  readonly object: Expression;\n  readonly property: Expression;\n  constructor(object: Expression, property: Expression) {\n    this.object = object;\n    this.property = property;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitGetExpression(this);\n  }\n  toString() {\n    return `${this.object.toString()}.${this.property.toString()}`;\n  }\n}\nexport class SetExpression implements Expression {\n  readonly object: GetExpression;\n  readonly value: Expression;\n  constructor(object: GetExpression, value: Expression) {\n    this.object = object;\n    this.value = value;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitSetExpression(this);\n  }\n  toString() {\n    return `${this.object.toString()} = ${this.value.toString()}`;\n  }\n}\nexport class GroupingExpression implements Expression {\n  readonly expression: Expression;\n  constructor(expression: Expression) {\n    this.expression = expression;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitGroupingExpression(this);\n  }\n  toString() {\n    return `(${this.expression.toString()})`;\n  }\n}\nexport class LiteralExpression implements Expression {\n  readonly value: LiteralType;\n  constructor(value: LiteralType) {\n    this.value = value;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitLiteralExpression(this);\n  }\n  toString() {\n    if (typeof this.value === 'string') {\n      return `'${this.value}'`;\n    }\n    return convertLiteralTypeToString(this.value);\n  }\n}\nexport class LogicalExpression implements Expression {\n  readonly left: Expression;\n  readonly operator: Token;\n  readonly right: Expression;\n  constructor(left: Expression, operator: Token, right: Expression) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitLogicalExpression(this);\n  }\n  toString() {\n    return `${this.left.toString()} ${this.operator.toString()} ${this.right.toString()}`;\n  }\n}\nexport class SuperExpression implements Expression {\n  readonly argumentList: Expression[];\n  constructor(argumentList: Expression[]) {\n    this.argumentList = argumentList;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitSuperExpression(this);\n  }\n  toString() {\n    return '';\n  }\n}\nexport class ThisExpression implements Expression {\n  readonly keyword: Token;\n  constructor(keyword: Token) {\n    this.keyword = keyword;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitThisExpression(this);\n  }\n  toString() {\n    return '';\n  }\n}\nexport class UnaryExpression implements Expression {\n  readonly operator: Token;\n  readonly right: Expression;\n  constructor(operator: Token, right: Expression) {\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitUnaryExpression(this);\n  }\n  toString() {\n    const temp = `${this.operator.toString()}${this.right.toString()}`;\n    if (isTestEnv()) {\n      return `(${temp})`;\n    }\n    return temp;\n  }\n}\nexport class VariableExpression implements Expression {\n  readonly name: Token;\n  constructor(name: Token) {\n    this.name = name;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitVariableExpression(this);\n  }\n  toString() {\n    return this.name.toString();\n  }\n}\n\nexport class FunctionExpression implements Expression {\n  readonly name: Token | null;\n  readonly body: BlockStatement;\n  readonly params: Token[];\n  constructor(name: Token | null, body: BlockStatement, params: Token[]) {\n    this.name = name;\n    this.body = body;\n    this.params = params;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitFunctionExpression(this);\n  }\n  toString() {\n    return `function ${\n      this.name === null ? '' : this.name.toString()\n    }(${this.params\n      .map((item) => item.toString())\n      .join(',')})${this.body.toString()}`;\n  }\n}\n\nexport class ArrayLiteralExpression implements Expression {\n  readonly elements: Expression[];\n  constructor(elements: Expression[]) {\n    this.elements = elements;\n  }\n  accept(visitor: ExpressionVisitor) {\n    return visitor.visitArrayLiteralExpression(this);\n  }\n  toString(): string {\n    return `[${this.elements.map((item) => item.toString()).join(',')}]`;\n  }\n}\nexport class ObjectLiteralExpression implements Expression {\n  readonly properties: Array<{ key: Expression; value: Expression }>;\n  constructor(properties: Array<{ key: Expression; value: Expression }>) {\n    this.properties = properties;\n  }\n  accept(visitor: ExpressionVisitor) {\n    return visitor.visitObjectLiteralExpression(this);\n  }\n  toString(): string {\n    return `{${this.properties.map(\n      (item) => `${item.key.toString()}:${item.value.toString()}`,\n    )}}`;\n  }\n}\nexport class TokenExpression implements Expression {\n  readonly token: Token;\n  constructor(token: Token) {\n    this.token = token;\n  }\n  accept(visitor: ExpressionVisitor) {\n    return visitor.visitTokenExpression(this);\n  }\n  toString(): string {\n    return this.token.toString();\n  }\n}\n\nexport class ClassExpression implements Expression {\n  readonly name: Token | null;\n  readonly superClass: VariableExpression | null;\n  readonly methods: Array<VariableStatement | FunctionStatement>;\n  constructor(\n    name: Token | null,\n    superClass: VariableExpression | null,\n    methods: Array<VariableStatement | FunctionStatement>,\n  ) {\n    this.name = name;\n    this.superClass = superClass;\n    this.methods = methods;\n  }\n  accept(visitor: ExpressionVisitor): LiteralType {\n    return visitor.visitClassExpression(this);\n  }\n  toString() {\n    return `class ${\n      this.name === null ? '' : this.name.toString()\n    }{${this.methods\n      .map((item) => {\n        const temp = item.toString();\n        const index = temp.indexOf(' ');\n        return temp.slice(index + 1);\n      })\n      .join('')}}`;\n  }\n}\n", "import type Token from './token';\nimport type { Expression, VariableExpression } from './expression';\nimport type { LiteralType } from './type';\nexport interface StatementVisitor {\n  visitBlockStatement: (statement: BlockStatement) => LiteralType;\n  visitClassStatement: (statement: ClassStatement) => LiteralType;\n  visitExpressionStatement: (statement: ExpressionStatement) => LiteralType;\n  visitFunctionStatement: (statement: FunctionStatement) => LiteralType;\n  visitIfStatement: (statement: IfStatement) => LiteralType;\n  visitReturnStatement: (statement: ReturnStatement) => LiteralType;\n  visitVariableStatement: (statement: VariableStatement) => LiteralType;\n  visitWhileStatement: (statement: WhileStatement) => LiteralType;\n}\nexport interface Statement {\n  accept(visitor: StatementVisitor): LiteralType;\n  toString(): string;\n}\nexport class BlockStatement implements Statement {\n  readonly statements: Statement[];\n  constructor(statements: Statement[]) {\n    this.statements = statements;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitBlockStatement(this);\n  }\n  toString() {\n    return `{${this.statements.map((item) => item.toString()).join('')}}`;\n  }\n}\nexport class ClassStatement implements Statement {\n  readonly name: Token;\n  readonly superClass: VariableExpression | null;\n  readonly methods: Array<VariableStatement | FunctionStatement>;\n  constructor(\n    name: Token,\n    superClass: VariableExpression | null,\n    methods: Array<VariableStatement | FunctionStatement>,\n  ) {\n    this.name = name;\n    this.superClass = superClass;\n    this.methods = methods;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitClassStatement(this);\n  }\n  toString() {\n    return `class ${this.name.toString()}{${this.methods\n      .map((item) => {\n        const temp = item.toString();\n        const index = temp.indexOf(' ');\n        return temp.slice(index + 1);\n      })\n      .join('')}}`;\n  }\n}\nexport class ExpressionStatement implements Statement {\n  readonly expression: Expression;\n  constructor(expression: Expression) {\n    this.expression = expression;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitExpressionStatement(this);\n  }\n  toString() {\n    return this.expression.toString() + ';';\n  }\n}\nexport class FunctionStatement implements Statement {\n  readonly name: Token;\n  readonly body: BlockStatement;\n  readonly params: Token[];\n  readonly static: boolean;\n  constructor(\n    name: Token,\n    body: BlockStatement,\n    params: Token[],\n    isStatic = false,\n  ) {\n    this.name = name;\n    this.body = body;\n    this.params = params;\n    this.static = isStatic;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitFunctionStatement(this);\n  }\n  toString() {\n    return `function ${this.static ? 'static ' : ''\n      }${this.name.toString()}(${this.params\n        .map((item) => item.toString())\n        .join(',')})${this.body.toString()}`;\n  }\n}\nexport class IfStatement implements Statement {\n  readonly condition: Expression;\n  readonly thenBranch: Statement;\n  readonly elseBranch: Statement | null;\n  constructor(\n    condition: Expression,\n    thenBranch: Statement,\n    elseBranch: Statement | null,\n  ) {\n    this.condition = condition;\n    this.thenBranch = thenBranch;\n    this.elseBranch = elseBranch;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitIfStatement(this);\n  }\n  toString() {\n    const temp = `if(${this.condition.toString()})${this.thenBranch.toString()}`;\n    if (this.elseBranch === null) {\n      return temp;\n    }\n    return `${temp} else ${this.elseBranch.toString()}`;\n  }\n}\nexport class ReturnStatement implements Statement {\n  readonly argument: Expression | null;\n  constructor(argument: Expression | null) {\n    this.argument = argument;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitReturnStatement(this);\n  }\n  toString() {\n    return `return ${this.argument === null ? '' : this.argument.toString()};`;\n  }\n}\nexport class VariableStatement implements Statement {\n  readonly name: Token;\n  readonly initializer: Expression | null;\n  readonly static: boolean;\n  constructor(name: Token, initializer: Expression | null, isStatic = false) {\n    this.name = name;\n    this.initializer = initializer;\n    this.static = isStatic;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitVariableStatement(this);\n  }\n  toString() {\n    const temp = `var ${this.static ? 'static ' : ''}${this.name.toString()}`;\n    if (this.initializer === null) {\n      return temp + ';';\n    }\n    return `${temp} = ${this.initializer.toString()};`;\n  }\n}\nexport class WhileStatement implements Statement {\n  readonly condition: Expression;\n  readonly body: Statement;\n  constructor(condition: Expression, body: Statement) {\n    this.condition = condition;\n    this.body = body;\n  }\n  accept(visitor: StatementVisitor): LiteralType {\n    return visitor.visitWhileStatement(this);\n  }\n  toString() {\n    return `while(${this.condition.toString()})${this.body.toString()}`;\n  }\n}\n", "import {\n  ArrayLiteralExpression,\n  AssignExpression,\n  BinaryExpression,\n  CallExpression,\n  ClassExpression,\n  Expression,\n  FunctionExpression,\n  GetExpression,\n  GroupingExpression,\n  LiteralExpression,\n  LogicalExpression,\n  NewExpression,\n  ObjectLiteralExpression,\n  SetExpression,\n  TokenExpression,\n  UnaryExpression,\n  VariableExpression,\n} from './expression';\nimport { TokenType } from './tokenType';\nimport Token from './token';\nimport {\n  BlockStatement,\n  ClassStatement,\n  ExpressionStatement,\n  FunctionStatement,\n  IfStatement,\n  ReturnStatement,\n  Statement,\n  VariableStatement,\n  WhileStatement,\n} from './statement';\nimport { KEYWORD_MAP } from './constant';\n\nconst assignmentMap: Map<TokenType, TokenType> = new Map([\n  [TokenType.PLUS_EQUAL, TokenType.PLUS],\n  [TokenType.PLUS_EQUAL, TokenType.PLUS],\n  [TokenType.MINUS_EQUAL, TokenType.MINUS],\n  [TokenType.STAR_STAR_EQUAL, TokenType.STAR_STAR],\n  [TokenType.STAR_EQUAL, TokenType.STAR],\n  [TokenType.SLASH_EQUAL, TokenType.SLASH],\n  [TokenType.REMAINDER_EQUAL, TokenType.REMAINDER],\n  [TokenType.LEFT_SHIFT_EQUAL, TokenType.LEFT_SHIFT],\n  [TokenType.RIGHT_SHIFT_EQUAL, TokenType.RIGHT_SHIFT],\n  [TokenType.UNSIGNED_RIGHT_SHIFT_EQUAL, TokenType.UNSIGNED_RIGHT_SHIFT],\n  [TokenType.BIT_AND_EQUAL, TokenType.BIT_AND],\n  [TokenType.BIT_X_OR_EQUAL, TokenType.BIT_X_OR],\n  [TokenType.BIT_OR_EQUAL, TokenType.BIT_OR],\n  [TokenType.OR_EQUAL, TokenType.OR],\n  [TokenType.AND_EQUAL, TokenType.AND],\n  [TokenType.NULLISH_COALESCING_EQUAL, TokenType.NULLISH_COALESCING],\n]);\n\nclass Parser {\n  private readonly tokens: Token[];\n  private current = 0;\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n  }\n  parse = (): Statement[] => {\n    const statements: Statement[] = [];\n    while (!this.isAtEnd()) {\n      statements.push(this.declaration());\n    }\n    return statements;\n  };\n  private declaration(): Statement {\n    if (this.match(TokenType.VAR)) {\n      return this.varDeclaration();\n    }\n\n    if (this.match(TokenType.CLASS)) {\n      const className = this.consume(TokenType.IDENTIFIER, 'expect class name');\n      const { superClass, methods } = this.getClassBody();\n      return new ClassStatement(className, superClass, methods);\n    }\n\n    if (this.match(TokenType.FUNCTION)) {\n      return this.functionDeclaration('Function');\n    }\n\n    return this.statement();\n  }\n  private getClassBody(): {\n    superClass: VariableExpression | null;\n    methods: Array<VariableStatement | FunctionStatement>;\n  } {\n    let superClass: VariableExpression | null = null;\n    if (this.match(TokenType.EXTENDS)) {\n      const name = this.consume(TokenType.IDENTIFIER, 'expect class');\n      superClass = new VariableExpression(name);\n    }\n    this.consume(TokenType.lEFT_BRACE, 'expect {');\n    let methods: Array<VariableStatement | FunctionStatement> = [];\n    while (!this.isAtEnd() && !this.check(TokenType.RIGHT_BRACE)) {\n      const isStatic = this.match(TokenType.STATIC);\n      if (this.checkNext(TokenType.LEFT_BRACKET)) {\n        methods.push(this.functionDeclaration('Class', isStatic));\n      } else {\n        methods.push(this.varDeclaration(isStatic));\n      }\n    }\n    this.consume(TokenType.RIGHT_BRACE, 'expect }');\n    return {\n      superClass,\n      methods,\n    };\n  }\n  private varDeclaration(isStatic = false): VariableStatement {\n    const name: Token = this.consume(\n      TokenType.IDENTIFIER,\n      'expect identifier after var',\n    );\n    let initializer: Expression | null = null;\n    if (this.match(TokenType.EQUAL)) {\n      initializer = this.expression();\n    }\n    this.match(TokenType.SEMICOLON);\n    return new VariableStatement(name, initializer, isStatic);\n  }\n  private functionDeclaration(\n    name: 'Function' | 'Class',\n    isStatic = false,\n  ): FunctionStatement {\n    const message = `${name} statements require a function name`;\n    let functionName: Token;\n    if (name === 'Function') {\n      functionName = this.consume(TokenType.IDENTIFIER, message);\n    } else {\n      functionName = this.consumeName(message);\n    }\n\n    const params = this.getTokens(name);\n    this.consume(TokenType.lEFT_BRACE, 'expect { after function parameters');\n    const block = this.blockStatement();\n    return new FunctionStatement(functionName, block, params, isStatic);\n  }\n  private statement(): Statement {\n    if (this.match(TokenType.IF)) {\n      return this.ifStatement();\n    }\n    if (this.match(TokenType.WHILE)) {\n      return this.whileStatement();\n    }\n    if (this.match(TokenType.DO_WHILE)) {\n      return this.doWhileStatement();\n    }\n    if (this.match(TokenType.FOR)) {\n      return this.forStatement();\n    }\n    if (this.match(TokenType.lEFT_BRACE)) {\n      return this.blockStatement();\n    }\n    if (this.match(TokenType.RETURN)) {\n      return this.returnStatement();\n    }\n    return this.expressionStatement();\n  }\n  private forStatement(): BlockStatement {\n    this.consume(TokenType.LEFT_BRACKET, 'expect (');\n    var initializer: Statement | null = null;\n    if (this.match(TokenType.VAR)) {\n      initializer = this.varDeclaration();\n    } else if (!this.check(TokenType.SEMICOLON)) {\n      initializer = this.expressionStatement();\n    } else {\n      this.consume(TokenType.SEMICOLON, 'expect ; after initializer');\n    }\n\n    let condition: Expression = new LiteralExpression(true);\n    if (!this.check(TokenType.SEMICOLON)) {\n      condition = this.expression();\n    }\n    this.consume(TokenType.SEMICOLON, 'expect ; after for condition');\n    let end: Expression | null = null;\n    if (!this.check(TokenType.RIGHT_BRACKET)) {\n      end = this.expression();\n    }\n    this.consume(TokenType.RIGHT_BRACKET, 'expect )');\n    const body = this.statement();\n    const list: Statement[] = [body];\n    if (end !== null) {\n      list.push(new ExpressionStatement(end));\n    }\n    const whileBody = new BlockStatement(list);\n    const whileStatement = new WhileStatement(condition, whileBody);\n    const statements: Statement[] = [];\n    if (initializer !== null) {\n      statements.push(initializer);\n    }\n    statements.push(whileStatement);\n    return new BlockStatement(statements);\n  }\n  private doWhileStatement(): BlockStatement {\n    this.consume(TokenType.lEFT_BRACE, 'expect {');\n    const body = this.blockStatement();\n    this.consume(TokenType.WHILE, 'expect while');\n    this.consume(TokenType.LEFT_BRACKET, 'expect (');\n    const expr = this.expression();\n    this.consume(TokenType.RIGHT_BRACKET, 'expect )');\n    const value = new WhileStatement(expr, body);\n    return new BlockStatement([body, value]);\n  }\n  private returnStatement(): ReturnStatement {\n    let value: Expression | null = null;\n    if (!this.check(TokenType.SEMICOLON)) {\n      value = this.expression();\n    }\n    this.match(TokenType.SEMICOLON);\n    return new ReturnStatement(value);\n  }\n  private whileStatement(): WhileStatement {\n    this.consume(TokenType.LEFT_BRACKET, 'expect ( after while');\n    const expression = this.expression();\n    this.consume(TokenType.RIGHT_BRACKET, 'expect ) after while');\n    const body = this.statement();\n    return new WhileStatement(expression, body);\n  }\n  private ifStatement(): IfStatement {\n    this.consume(TokenType.LEFT_BRACKET, 'expect ( after if');\n    const expression = this.expression();\n    this.consume(TokenType.RIGHT_BRACKET, 'expect ) after if');\n    const thenBranch: Statement = this.statement();\n    let elseBranch: Statement | null = null;\n    if (this.match(TokenType.ELSE)) {\n      elseBranch = this.statement();\n    }\n    return new IfStatement(expression, thenBranch, elseBranch);\n  }\n  private blockStatement(): BlockStatement {\n    const statements: Statement[] = [];\n    while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\n      statements.push(this.declaration());\n    }\n    this.consume(TokenType.RIGHT_BRACE, 'expect } after block');\n    return new BlockStatement(statements);\n  }\n  private expressionStatement(): ExpressionStatement {\n    const expr = this.expression();\n    this.match(TokenType.SEMICOLON);\n    return new ExpressionStatement(expr);\n  }\n  public expression(): Expression {\n    return this.assignment();\n  }\n  private assignment(): Expression {\n    const expr = this.or();\n    if (this.match(TokenType.EQUAL, ...assignmentMap.keys())) {\n      const equal: Token = this.previous();\n      let value = this.assignment();\n      const temp = assignmentMap.get(equal.type);\n      if (temp) {\n        const operator = new Token(\n          temp,\n          equal.lexeme.replace('=', ''),\n          equal.line,\n        );\n        if (\n          equal.type === TokenType.AND_EQUAL ||\n          equal.type === TokenType.OR_EQUAL ||\n          equal.type === TokenType.NULLISH_COALESCING_EQUAL\n        ) {\n          value = new LogicalExpression(expr, operator, value);\n        } else {\n          value = new BinaryExpression(expr, operator, value);\n        }\n      }\n      if (expr instanceof VariableExpression) {\n        const name = expr.name;\n        return new AssignExpression(name, value);\n      } else if (expr instanceof GetExpression) {\n        return new SetExpression(expr, value);\n      }\n      throw new Error(`invalid assign target: ${equal}`);\n    }\n    return expr;\n  }\n\n  private or(): Expression {\n    let expr = this.and();\n    while (this.match(TokenType.OR, TokenType.NULLISH_COALESCING)) {\n      const operator = this.previous();\n      const right = this.and();\n      expr = new LogicalExpression(expr, operator, right);\n    }\n    return expr;\n  }\n\n  private and(): Expression {\n    let expr = this.bitOr();\n    while (this.match(TokenType.AND)) {\n      const operator = this.previous();\n      const right = this.bitOr();\n      expr = new LogicalExpression(expr, operator, right);\n    }\n    return expr;\n  }\n\n  private bitOr(): Expression {\n    let expr = this.bitXOr();\n    while (this.match(TokenType.BIT_OR)) {\n      const operator = this.previous();\n      const right = this.bitXOr();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n\n  private bitXOr(): Expression {\n    let expr = this.bitAnd();\n    while (this.match(TokenType.BIT_X_OR)) {\n      const operator = this.previous();\n      const right = this.bitAnd();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n\n  private bitAnd(): Expression {\n    let expr = this.equality();\n    while (this.match(TokenType.BIT_AND)) {\n      const operator = this.previous();\n      const right = this.equality();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n\n  private equality(): Expression {\n    let expr: Expression = this.comparison();\n    while (\n      this.match(\n        TokenType.BANG_EQUAL,\n        TokenType.BANG_EQUAL_EQUAL,\n        TokenType.EQUAL_EQUAL,\n        TokenType.EQUAL_EQUAL_EQUAL,\n      )\n    ) {\n      const operator: Token = this.previous();\n      const right: Expression = this.comparison();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n  private comparison(): Expression {\n    let bitwiseShift: Expression = this.bitwiseShift();\n    while (\n      this.match(\n        TokenType.GREATER,\n        TokenType.GREATER_EQUAL,\n        TokenType.LESS,\n        TokenType.LESS_EQUAL,\n        TokenType.IN,\n        TokenType.INSTANCE_OF,\n      )\n    ) {\n      const operator: Token = this.previous();\n      const right: Expression = this.bitwiseShift();\n      bitwiseShift = new BinaryExpression(bitwiseShift, operator, right);\n    }\n    return bitwiseShift;\n  }\n  private bitwiseShift(): Expression {\n    let term: Expression = this.term();\n    while (\n      this.match(\n        TokenType.LEFT_SHIFT,\n        TokenType.RIGHT_SHIFT,\n        TokenType.UNSIGNED_RIGHT_SHIFT,\n      )\n    ) {\n      const operator: Token = this.previous();\n      const right: Expression = this.term();\n      term = new BinaryExpression(term, operator, right);\n    }\n    return term;\n  }\n  private term(): Expression {\n    let factor: Expression = this.factor();\n    while (this.match(TokenType.PLUS, TokenType.MINUS)) {\n      const operator: Token = this.previous();\n      const right: Expression = this.factor();\n      factor = new BinaryExpression(factor, operator, right);\n    }\n    return factor;\n  }\n  private factor(): Expression {\n    let exponentiation: Expression = this.exponentiation();\n    while (this.match(TokenType.STAR, TokenType.SLASH, TokenType.REMAINDER)) {\n      const operator: Token = this.previous();\n      const right: Expression = this.exponentiation();\n      exponentiation = new BinaryExpression(exponentiation, operator, right);\n    }\n    return exponentiation;\n  }\n  private exponentiation(): Expression {\n    let unary: Expression = this.unary();\n    while (this.match(TokenType.STAR_STAR)) {\n      const operator: Token = this.previous();\n      const right: Expression = this.exponentiation();\n      unary = new BinaryExpression(unary, operator, right);\n    }\n    return unary;\n  }\n  private unary(): Expression {\n    if (\n      this.match(\n        TokenType.BANG,\n        TokenType.BIT_NOT,\n        TokenType.MINUS,\n        TokenType.PLUS,\n        TokenType.PLUS_PLUS,\n        TokenType.MINUS_MINUS,\n        TokenType.TYPEOF,\n        TokenType.VOID,\n        TokenType.DELETE,\n      )\n    ) {\n      const operator: Token = this.previous();\n      const value = this.unary();\n      return new UnaryExpression(operator, value);\n    }\n    return this.newExpression();\n  }\n  private newExpression(): Expression {\n    if (this.match(TokenType.NEW)) {\n      return new NewExpression(this.call());\n    }\n    return this.call();\n  }\n  private call(): Expression {\n    let expr: Expression = this.primary();\n    while (true) {\n      if (this.match(TokenType.LEFT_BRACKET)) {\n        expr = this.finishCall(expr);\n      } else if (this.match(TokenType.DOT)) {\n        const property = this.consumeName('expect name');\n        expr = new GetExpression(expr, new TokenExpression(property));\n      } else if (this.match(TokenType.LEFT_SQUARE_BRACKET)) {\n        const property = this.expression();\n        this.consume(TokenType.RIGHT_SQUARE_BRACKET, 'expect ]');\n        expr = new GetExpression(expr, property);\n      } else {\n        break;\n      }\n    }\n    return expr;\n  }\n  private getExpressions(tokenType: TokenType) {\n    const params: Expression[] = [];\n    if (!this.check(tokenType)) {\n      do {\n        params.push(this.expression());\n      } while (this.match(TokenType.COMMA));\n    }\n    return params;\n  }\n  private finishCall(callee: Expression): Expression {\n    const params = this.getExpressions(TokenType.RIGHT_BRACKET);\n    this.consume(TokenType.RIGHT_BRACKET, 'expect ) after arguments');\n    return new CallExpression(callee, params);\n  }\n  private getTokens(name: string): Token[] {\n    const params: Token[] = [];\n    this.consume(TokenType.LEFT_BRACKET, `expect ( after ${name}`);\n    if (!this.check(TokenType.RIGHT_BRACKET)) {\n      do {\n        params.push(\n          this.consume(TokenType.IDENTIFIER, 'expect parameter name'),\n        );\n      } while (this.match(TokenType.COMMA));\n    }\n    this.consume(TokenType.RIGHT_BRACKET, `expect ) after ${name}`);\n    return params;\n  }\n\n  private functionExpression(): FunctionExpression {\n    let functionName: Token | null = null;\n    if (this.match(TokenType.IDENTIFIER)) {\n      functionName = this.previous();\n    }\n    const params = this.getTokens('expression');\n    this.consume(TokenType.lEFT_BRACE, 'expect { after function parameters');\n    const block = this.blockStatement();\n    return new FunctionExpression(functionName, block, params);\n  }\n  private classExpression(): ClassExpression {\n    let name: Token | null = null;\n    if (this.match(TokenType.IDENTIFIER)) {\n      name = this.previous();\n    }\n    const { superClass, methods } = this.getClassBody();\n    return new ClassExpression(name, superClass, methods);\n  }\n  private primary(): Expression {\n    if (this.match(TokenType.TRUE)) {\n      return new LiteralExpression(true);\n    }\n    if (this.match(TokenType.FALSE)) {\n      return new LiteralExpression(false);\n    }\n    if (this.match(TokenType.UNDEFINED)) {\n      return new LiteralExpression(undefined);\n    }\n    if (this.match(TokenType.NULL)) {\n      return new LiteralExpression(null);\n    }\n    if (this.match(TokenType.NUMBER)) {\n      return new LiteralExpression(parseFloat(this.previous().lexeme));\n    }\n    if (this.match(TokenType.STRING)) {\n      return new LiteralExpression(this.previous().lexeme);\n    }\n    if (this.match(TokenType.IDENTIFIER)) {\n      return new VariableExpression(this.previous());\n    }\n    if (this.match(TokenType.LEFT_BRACKET)) {\n      const expr: Expression = this.expression();\n      this.consume(\n        TokenType.RIGHT_BRACKET,\n        `parser expected: '(',actual: ${this.peek().toString()}`,\n      );\n      return new GroupingExpression(expr);\n    }\n    if (this.match(TokenType.FUNCTION)) {\n      return this.functionExpression();\n    }\n    if (this.match(TokenType.CLASS)) {\n      return this.classExpression();\n    }\n    if (this.match(TokenType.LEFT_SQUARE_BRACKET)) {\n      const value = this.getExpressions(TokenType.RIGHT_SQUARE_BRACKET);\n      this.consume(TokenType.RIGHT_SQUARE_BRACKET, 'expect ]');\n      return new ArrayLiteralExpression(value);\n    }\n    if (this.match(TokenType.lEFT_BRACE)) {\n      const valueList: Array<{ key: Expression; value: Expression }> = [];\n      if (!this.check(TokenType.RIGHT_BRACE)) {\n        do {\n          if (this.check(TokenType.RIGHT_BRACE)) {\n            break;\n          }\n          const key = this.consumeName('expect key');\n          this.consume(TokenType.COLON, 'expect :');\n          const value = this.expression();\n          valueList.push({ key: new TokenExpression(key), value });\n        } while (this.match(TokenType.COMMA));\n      }\n      this.consume(TokenType.RIGHT_BRACE, 'expect }');\n      return new ObjectLiteralExpression(valueList);\n    }\n\n    throw new Error(`parser can not handle token: ${this.peek().toString()}`);\n  }\n  private consume(type: TokenType, message: string) {\n    if (this.peek().type === type) {\n      this.advance();\n      return this.previous();\n    }\n    throw new Error(message);\n  }\n  private consumeName(message: string) {\n    const list = Array.from(KEYWORD_MAP.values());\n    list.push(TokenType.IDENTIFIER);\n    return this.consumes(message, ...list);\n  }\n  private consumes(message: string, ...types: TokenType[]) {\n    const type = this.peek().type;\n    if (types.some((v) => v === type)) {\n      this.advance();\n      return this.previous();\n    }\n    throw new Error(message);\n  }\n  private previous(): Token {\n    return this.tokens[this.current - 1] as Token;\n  }\n  private match(...types: TokenType[]): boolean {\n    for (let type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n  private advance() {\n    if (this.isAtEnd()) {\n      return;\n    }\n    this.current++;\n  }\n  private check(type: TokenType) {\n    if (this.isAtEnd()) {\n      return false;\n    }\n    return this.peek().type === type;\n  }\n  private checkNext(type: TokenType) {\n    if (this.isAtEnd()) {\n      return false;\n    }\n    return (this.tokens[this.current + 1] as Token).type === type;\n  }\n  private isAtEnd(): boolean {\n    return this.peek().type === TokenType.EOF;\n  }\n  private peek(): Token {\n    return this.tokens[this.current] as Token;\n  }\n}\n\nexport default Parser;\n", "import type { LiteralType, Environment } from './type';\nclass EnvironmentImpl implements Environment {\n  private readonly values = new Map<string, LiteralType>();\n  private parent: Environment | null = null;\n  constructor(parent: Environment | null) {\n    this.parent = parent;\n  }\n  get(name: string): LiteralType {\n    if (this.values.has(name)) {\n      return this.values.get(name) as LiteralType;\n    }\n    if (this.parent !== null) {\n      return this.parent.get(name);\n    }\n    return undefined\n  }\n  define(name: string, value: LiteralType) {\n    this.values.set(name, value);\n  }\n  assign(name: string, value: LiteralType) {\n    if (this.values.has(name)) {\n      this.values.set(name, value);\n      return;\n    }\n    if (this.parent !== null) {\n      this.parent.assign(name, value);\n      return;\n    }\n    this.values.set(name, value)\n  }\n}\n\nexport default EnvironmentImpl;\n", "import type {\n  LiteralType,\n  IBaseCallable,\n  Interpreter,\n  Environment,\n} from './type';\nimport type { FunctionStatement } from './statement';\nimport EnvironmentImpl from './environment';\nimport { FunctionExpression } from './expression';\n\nclass FunctionObject implements IBaseCallable {\n  private readonly declaration: FunctionStatement | FunctionExpression;\n  private readonly closure: Environment | null;\n  constructor(\n    declaration: FunctionStatement | FunctionExpression,\n    closure: Environment | null,\n  ) {\n    this.declaration = declaration;\n    this.closure = closure;\n  }\n  call(interpreter: Interpreter, argumentList: LiteralType[]): LiteralType {\n    const env = new EnvironmentImpl(this.closure);\n    if (\n      this.declaration instanceof FunctionExpression &&\n      this.declaration.name !== null\n    ) {\n      env.define(this.declaration.name.lexeme, this);\n    }\n    for (let i = 0; i < this.declaration.params.length; i++) {\n      env.define(this.declaration.params[i]?.lexeme!, argumentList[i]);\n    }\n    return interpreter.executeBlock(this.declaration.body, env);\n  }\n  toString() {\n    return this.declaration.toString();\n  }\n}\n\nexport { FunctionObject };\n", "import type { LiteralType } from './type';\n\nclass ReturnValue {\n  value: LiteralType;\n  constructor(value: LiteralType) {\n    this.value = value;\n  }\n}\n\nexport { ReturnValue };\n", "import type { LiteralType, IBaseCallable, ObjectType, Interpreter } from './type';\nimport { ClassStatement, FunctionStatement } from './statement';\nimport { FunctionObject } from './function';\nimport EnvironmentImpl from './environment';\nimport { ClassExpression } from './expression';\n\nexport class ClassObject implements IBaseCallable {\n  private readonly statement: ClassStatement | ClassExpression;\n  readonly staticMethods: ObjectType = {};\n  constructor(statement: ClassStatement | ClassExpression) {\n    this.statement = statement;\n  }\n  call(interpreter: Interpreter, argumentList: LiteralType[]): LiteralType {\n    const instance: ObjectType = {};\n    const env = new EnvironmentImpl(interpreter.environment);\n\n    if (\n      this.statement instanceof ClassExpression &&\n      this.statement.name !== null\n    ) {\n      env.define(this.statement.name.lexeme, this);\n    }\n    if (this.statement.superClass !== null) {\n      const temp = interpreter.evaluate(this.statement.superClass);\n      if (temp instanceof ClassObject) {\n        const superData: IBaseCallable = {\n          call(interpreter: Interpreter, argumentList: LiteralType[]) {\n            const originInstance = temp.call(interpreter, argumentList);\n            for (const key of Object.keys(originInstance)) {\n              instance[key] = originInstance[key];\n            }\n          },\n          toString() {\n            return 'super';\n          },\n        };\n        env.define('super', superData);\n      } else {\n        throw new Error(\n          `Class extends value ${temp} is not a constructor or null`,\n        );\n      }\n    }\n    env.define('this', instance);\n    for (const item of this.statement.methods) {\n      if (item.static) {\n        continue;\n      }\n      if (item instanceof FunctionStatement) {\n        if (item.name.lexeme === 'constructor') {\n          const temp = new FunctionObject(item, env);\n          temp.call(interpreter, argumentList);\n        } else {\n          instance[item.name.lexeme] = new FunctionObject(item, env);\n        }\n      } else {\n        let temp: LiteralType = null;\n        if (item.initializer != null) {\n          temp = interpreter.evaluate(item.initializer);\n        }\n        instance[item.name.lexeme] = temp;\n      }\n    }\n    return instance;\n  }\n  toString() {\n    return this.statement.toString();\n  }\n}\n", "import type { LiteralType, ObjectType, Interpreter, Environment } from './type';\n\nimport type {\n  BinaryExpression,\n  GroupingExpression,\n  LiteralExpression,\n  UnaryExpression,\n  AssignExpression,\n  CallExpression,\n  GetExpression,\n  SetExpression,\n  LogicalExpression,\n  Expression,\n  NewExpression,\n  FunctionExpression,\n  ArrayLiteralExpression,\n  ObjectLiteralExpression,\n  TokenExpression,\n  ClassExpression,\n} from './expression';\nimport { VariableExpression } from './expression';\nimport { TokenType } from './tokenType';\n\nimport type {\n  IfStatement,\n  ReturnStatement,\n  ExpressionStatement,\n  Statement,\n  BlockStatement,\n  WhileStatement,\n  ClassStatement,\n  VariableStatement,\n} from './statement';\nimport { FunctionStatement } from './statement';\nimport { isBaseCallable, assert, isObject } from './util';\nimport { FunctionObject } from './function';\nimport { ReturnValue } from './return';\nimport { ClassObject } from './class';\n\nclass InterpreterImpl implements Interpreter {\n  environment: Environment;\n  private readonly statements: Statement[];\n  private calleeKey: string = '';\n  private calleeValue: ObjectType | undefined = undefined;\n  constructor(statements: Statement[], environment: Environment) {\n    this.environment = environment;\n    this.statements = statements;\n  }\n  interpret = (): LiteralType => {\n    let result: LiteralType = null;\n    for (const item of this.statements) {\n      result = this.execute(item);\n      if (result instanceof ReturnValue) {\n        return result.value;\n      }\n    }\n    return result;\n  };\n  private execute = (statement: Statement): LiteralType => {\n    return statement.accept(this);\n  };\n  evaluate = (expr: Expression): LiteralType => {\n    const result = expr.accept(this);\n    if (result instanceof ReturnValue) {\n      return result.value;\n    }\n    return result;\n  };\n  private visitClass = (\n    expression: ClassExpression | ClassStatement,\n  ): ClassObject => {\n    const instance = new ClassObject(expression);\n    if (expression.superClass !== null) {\n      const temp = this.evaluate(expression.superClass);\n      if (temp instanceof ClassObject) {\n        for (const key of Object.keys(temp.staticMethods)) {\n          instance.staticMethods[key] = temp.staticMethods[key];\n        }\n      } else {\n        throw new Error(\n          `Class extends value ${temp} is not a constructor or null`,\n        );\n      }\n    }\n    for (const item of expression.methods) {\n      if (item.static) {\n        let temp: LiteralType = null;\n        if (item instanceof FunctionStatement) {\n          temp = new FunctionObject(item, this.environment);\n        } else {\n          if (item.initializer != null) {\n            temp = this.evaluate(item.initializer);\n          }\n        }\n        instance.staticMethods[item.name.lexeme] = temp;\n      }\n    }\n    return instance;\n  };\n\n  visitExpressionStatement = (statement: ExpressionStatement) => {\n    return this.evaluate(statement.expression);\n  };\n  visitBlockStatement = (statement: BlockStatement) => {\n    return this.executeBlock(statement, this.environment);\n  };\n  executeBlock = (\n    statement: BlockStatement,\n    environment: Environment,\n  ): LiteralType => {\n    const previous = this.environment;\n    let result: LiteralType = null;\n    this.environment = environment;\n    for (let item of statement.statements) {\n      result = this.execute(item);\n      if (result instanceof ReturnValue) {\n        this.environment = previous;\n        return result;\n      }\n    }\n    this.environment = previous;\n    return result;\n  };\n  visitClassStatement = (statement: ClassStatement) => {\n    const instance = this.visitClass(statement);\n    this.environment.define(statement.name.lexeme, instance);\n    return null;\n  };\n  visitNewExpression = (expression: NewExpression) => {\n    const classObject = this.evaluate(expression.callee);\n    assert(\n      isObject(classObject),\n      `Class constructor ${expression.callee.toString()} cannot be invoked without 'new'`,\n    );\n    return classObject;\n  };\n  visitFunctionStatement = (statement: FunctionStatement) => {\n    this.environment.define(\n      statement.name.lexeme,\n      new FunctionObject(statement, this.environment),\n    );\n    return null;\n  };\n  visitFunctionExpression = (expression: FunctionExpression) => {\n    return new FunctionObject(expression, this.environment);\n  };\n  visitCallExpression = (expr: CallExpression): LiteralType => {\n    const callee: LiteralType = this.evaluate(expr.callee);\n    const argumentList: LiteralType[] = [];\n    for (let item of expr.argumentList) {\n      argumentList.push(this.evaluate(item));\n    }\n    if (!isBaseCallable(callee)) {\n      throw new Error('can only call functions');\n    }\n    return callee.call(this, argumentList);\n  };\n  visitIfStatement = (statement: IfStatement) => {\n    let result: LiteralType = null;\n    if (this.isTruthy(this.evaluate(statement.condition))) {\n      result = this.execute(statement.thenBranch);\n    } else if (statement.elseBranch) {\n      result = this.execute(statement.elseBranch);\n    }\n    if (result instanceof ReturnValue) {\n      return result;\n    }\n    return null;\n  };\n\n  visitReturnStatement = (statement: ReturnStatement) => {\n    let result: LiteralType = undefined;\n    if (statement.argument !== null) {\n      result = this.evaluate(statement.argument);\n    }\n    return new ReturnValue(result);\n  };\n  visitVariableStatement = (statement: VariableStatement) => {\n    let value = null;\n    if (statement.initializer !== null) {\n      value = this.evaluate(statement.initializer);\n    }\n    this.environment.define(statement.name.lexeme, value);\n    return null;\n  };\n  visitWhileStatement = (statement: WhileStatement) => {\n    while (this.isTruthy(this.evaluate(statement.condition))) {\n      const result = this.execute(statement.body);\n      if (result instanceof ReturnValue) {\n        return result;\n      }\n    }\n    return null;\n  };\n\n  visitAssignExpression = (expr: AssignExpression) => {\n    const temp: LiteralType = this.evaluate(expr.right);\n    this.environment.assign(expr.left.lexeme, temp);\n    return temp;\n  };\n  visitBinaryExpression = (expr: BinaryExpression): LiteralType => {\n    const left: LiteralType = this.evaluate(expr.left);\n    const right: LiteralType = this.evaluate(expr.right);\n    switch (expr.operator.type) {\n      case TokenType.MINUS:\n        return left - right;\n      case TokenType.PLUS:\n        return left + right;\n      case TokenType.STAR:\n        return left * right;\n      case TokenType.REMAINDER:\n        return left % right;\n      case TokenType.SLASH:\n        return left / right;\n      case TokenType.GREATER:\n        return left > right;\n      case TokenType.GREATER_EQUAL:\n        return left >= right;\n      case TokenType.LESS:\n        return left < right;\n      case TokenType.LESS_EQUAL:\n        return left <= right;\n      case TokenType.BANG_EQUAL:\n        return left != right;\n      case TokenType.BANG_EQUAL_EQUAL:\n        return left !== right;\n      case TokenType.EQUAL_EQUAL:\n        return left == right;\n      case TokenType.EQUAL_EQUAL_EQUAL:\n        return left === right;\n      case TokenType.LEFT_SHIFT:\n        return left << right;\n      case TokenType.RIGHT_SHIFT:\n        return left >> right;\n      case TokenType.UNSIGNED_RIGHT_SHIFT:\n        return left >>> right;\n      case TokenType.STAR_STAR:\n        return left ** right;\n      case TokenType.BIT_AND:\n        return left & right;\n      case TokenType.BIT_OR:\n        return left | right;\n      case TokenType.BIT_X_OR:\n        return left ^ right;\n      case TokenType.IN:\n        return left in right;\n      case TokenType.INSTANCE_OF:\n        return left instanceof right;\n    }\n    return null;\n  };\n\n  visitGetExpression = (expr: GetExpression) => {\n    const callee = this.evaluate(expr.object);\n    const key = this.evaluate(expr.property);\n    this.calleeKey = key;\n    if (callee instanceof ClassObject && key in callee.staticMethods) {\n      this.calleeValue = callee.staticMethods;\n      return callee.staticMethods[key];\n    }\n    this.calleeValue = callee;\n    return callee[key];\n  };\n  visitSetExpression = (expr: SetExpression): LiteralType => {\n    this.calleeKey = '';\n    this.calleeValue = undefined;\n    this.evaluate(expr.object);\n    const key = this.calleeKey;\n    const callee: ObjectType | undefined = this.calleeValue;\n    const value = this.evaluate(expr.value);\n    if (callee && isObject(callee)) {\n      // @ts-ignore\n      callee[key] = value;\n      return value;\n    }\n    throw new Error('error SetExpression');\n  };\n  visitLogicalExpression = (expr: LogicalExpression) => {\n    const left = this.evaluate(expr.left);\n    if (expr.operator.type === TokenType.OR) {\n      if (this.isTruthy(left)) {\n        return left;\n      }\n    } else if (expr.operator.type === TokenType.AND) {\n      if (!this.isTruthy(left)) {\n        return left;\n      }\n    } else if (expr.operator.type === TokenType.NULLISH_COALESCING) {\n      if (left !== null && left !== undefined) {\n        return left;\n      }\n    } else {\n      throw new Error(\n        `can no handle logic operator: ${expr.operator.toString()}`,\n      );\n    }\n    return this.evaluate(expr.right);\n  };\n  visitSuperExpression = (): LiteralType => {\n    return null;\n  };\n  visitThisExpression = (): LiteralType => {\n    return null;\n  };\n  visitVariableExpression = (expr: VariableExpression): LiteralType => {\n    return this.environment.get(expr.name.lexeme);\n  };\n  visitGroupingExpression = (expr: GroupingExpression): LiteralType => {\n    return this.evaluate(expr.expression);\n  };\n  visitLiteralExpression = (expr: LiteralExpression): LiteralType => {\n    return expr.value;\n  };\n  visitUnaryExpression = (expr: UnaryExpression): LiteralType => {\n    const isDelete = expr.operator.type === TokenType.DELETE;\n    if (isDelete) {\n      this.calleeKey = '';\n      this.calleeValue = undefined;\n    }\n    const right: LiteralType = this.evaluate(expr.right);\n    switch (expr.operator.type) {\n      case TokenType.MINUS:\n        return -right;\n      case TokenType.PLUS:\n        return right;\n      case TokenType.BIT_NOT:\n        return ~right;\n      case TokenType.BANG:\n        return !this.isTruthy(right);\n      case TokenType.TYPEOF:\n        return typeof right;\n      case TokenType.DELETE: {\n        if (this.calleeValue === undefined) {\n          throw new ReferenceError('is not defined');\n        }\n        return delete this.calleeValue[this.calleeKey];\n      }\n      case TokenType.VOID:\n        return undefined;\n      case TokenType.PLUS_PLUS:\n      case TokenType.MINUS_MINUS: {\n        assert(\n          expr.right instanceof VariableExpression,\n          'Invalid left-hand side expression in prefix operation',\n        );\n        let result = right;\n        if (expr.operator.type === TokenType.MINUS_MINUS) {\n          result--;\n        } else {\n          result++;\n        }\n        this.environment.assign(expr.right.name.lexeme, result);\n        return result;\n      }\n    }\n    return null;\n  };\n\n  private isTruthy(value: LiteralType) {\n    if (value === null) {\n      return false;\n    }\n    return Boolean(value);\n  }\n  visitArrayLiteralExpression = (expression: ArrayLiteralExpression) => {\n    const value = expression.elements.map((item) => this.evaluate(item));\n    return value;\n  };\n  visitObjectLiteralExpression = (expression: ObjectLiteralExpression) => {\n    const instance: ObjectType = {};\n    for (const item of expression.properties) {\n      const key = this.evaluate(item.key);\n      const value = this.evaluate(item.value);\n      instance[key] = value;\n    }\n    return instance;\n  };\n  visitTokenExpression = (expression: TokenExpression) => {\n    return expression.token.lexeme;\n  };\n  visitClassExpression = (expression: ClassExpression) => {\n    return this.visitClass(expression);\n  };\n}\n\nexport default InterpreterImpl;\n", "import Scanner from './scanner';\nimport Parser from './parser';\nimport InterpreterImpl from './interpreter';\nimport type { LiteralType, Environment } from './type';\n\nexport function interpret(text: string, environment: Environment): LiteralType {\n  const scanner = new Scanner(text);\n  const tokens = scanner.scan();\n  const parser = new Parser(tokens);\n  const statements = parser.parse();\n  const interpreter = new InterpreterImpl(statements, environment);\n  return interpreter.interpret();\n}\n", "import type {\n  LiteralType,\n  IBaseCallable,\n  ObjectType,\n  IGlobalConsole,\n  Environment,\n} from './type';\nimport { isBaseCallable } from './util';\n\nconst consoleTypes = ['log', 'error'] as const;\ntype ConsoleType = typeof consoleTypes[number];\n\nfunction getConsoleImplement(\n  type: ConsoleType,\n  consoleObject: IGlobalConsole,\n): IBaseCallable {\n  return {\n    call(_, argumentList: LiteralType[]) {\n      const result: LiteralType[] = [];\n      for (const item of argumentList) {\n        if (isBaseCallable(item)) {\n          result.push(item.toString());\n        } else {\n          result.push(item);\n        }\n      }\n      consoleObject[type](...result);\n    },\n    toString() {\n      return `function ${type}() { [native code] }`;\n    },\n  };\n}\n\nfunction getGlobalObject(consoleObject: IGlobalConsole) {\n  const consoleInstance: ObjectType = {};\n  for (const type of consoleTypes) {\n    consoleInstance[type] = getConsoleImplement(type, consoleObject);\n  }\n  return {\n    console: consoleInstance,\n  };\n}\n\nfunction registerGlobal(environment: Environment) {\n  const temp = getGlobalObject(console);\n  const keyList = Object.keys(temp) as Array<\n    keyof ReturnType<typeof getGlobalObject>\n  >;\n  for (const key of keyList) {\n    environment.define(key, temp[key]);\n  }\n}\n\nexport { getGlobalObject, registerGlobal };\n"],
  "mappings": "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",
  "names": ["interpreter", "argumentList"]
}
